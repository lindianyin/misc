<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LibU: Networking</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Intro</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Networking</h1><hr/><a name="_details"></a><h2>Overview</h2>
<p>The <a class="el" href="group__net.html">Networking</a> module defines the following private URI schemes corresponding to the protocol combos:</p>
<table class="doxtable">
<tr>
<td></td><td><b>TCP</b> </td><td><b>UDP</b> </td><td><b>SCTP</b>  </td></tr>
<tr>
<td><b>IPv4</b> </td><td><code>tcp://</code> or <code>tcp4://</code> </td><td><code>udp://</code> or <code>udp4://</code> </td><td><code>sctp://</code> or <code>sctp4://</code>  </td></tr>
<tr>
<td><b>IPv6</b> </td><td><code>tcp6://</code> </td><td><code>udp6://</code> </td><td><code>sctp6://</code>  </td></tr>
<tr>
<td><b>UNIX</b> </td><td><code>unix://</code> </td><td>N.A. </td><td>N.A.  </td></tr>
</table>
<p>Except for <code>unix://</code> , which accepts only a valid pathname in the target file system, e.g.:</p>
<ul>
<li><code> unix:///tmp/my.sock </code></li>
</ul>
<p>every other scheme needs an <b>host</b> (by name or numeric address) and a <b>port</b> (by service name, or numeric in range <code>[1..65535]</code>) separated by a single <code>'</code>:' character, e.g.:</p>
<ul>
<li><code> tcp://www.kame.net:http </code></li>
<li><code> udp6://[fe80::200:f8ff:fe21:67cf]:65432 </code></li>
<li><code> sctp4://myhost:9999 </code></li>
</ul>
<p>Note that IPv6 numeric addresses must be enclosed with brackets as per RFC 3986.</p>
<p>Also, the wildcard address is specified with a <code>'*'</code>, and the same representation is used to let the kernel choose an ephemeral port for us. e.g.:</p>
<ul>
<li><code> tcp6://[*]:1025 </code></li>
<li><code> tcp4://192.168.0.1:* </code></li>
</ul>
<p>There exist two ways to obtain a socket descriptor: the first creates and consumes an address object without the caller ever noticing it and is ideal for one-shot initialization and use, e.g. a passive socket which is created once and accept'ed multiple times during the process lifetime: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> sd, asd;
    <span class="keyword">struct </span>sockaddr_storage sa;
    socklen_t sa_len = <span class="keyword">sizeof</span> sa;

    <span class="comment">// create a passive TCP socket</span>
    dbg_err_if ((sd = <a class="code" href="group__net.html#gabf242ab2c9cc25cebafb496e0f5a5bb5" title="Wrapper to u_net_sd_ex() with no timeout.">u_net_sd</a>(<span class="stringliteral">&quot;tcp://my:http-alt&quot;</span>, <a class="code" href="group__net.html#gga0e2b0aab1583067ab279f8d3ceacf2c3a771100a6478c29b42e870aad0c3b5f08">U_NET_SSOCK</a>, 0)) == -1);

    <span class="keywordflow">for</span> (;;)
    {
        <span class="comment">// accept new incoming connections</span>
        asd = <a class="code" href="group__net.html#gaf9ec5224c6979e3e3ff7ef267d2fe55f" title="accept(2) wrapper that handles EINTR ">u_accept</a>(sd, (<span class="keyword">struct</span> sockaddr *) &amp;sa, &amp;sa_len);

        dbg_ifb (asd == -1)
            continue;

        <span class="comment">// handle it</span>
        do_serve(asd);
    }
</pre></div><p>The second allows to reuse the same address object multiple times, and could easily fit a scenario where a transient connection must be set up on regular basis: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> csd;
    <a class="code" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750" title="Base type of the net module: holds all the addressing and semantics information needed...">u_net_addr_t</a> *a = NULL;

    <span class="comment">// create an address object for an active TCP socket</span>
    dbg_err_if (<a class="code" href="group__net.html#gaccf28473916f348ca587c535954504ff" title="Parse the supplied uri and transform it into an u_net_addr_t .">u_net_uri2addr</a>(<span class="stringliteral">&quot;tcp://my:http-alt&quot;</span>, <a class="code" href="group__net.html#gga0e2b0aab1583067ab279f8d3ceacf2c3a727f38a9217dbe236a5fe0fe95357ce2">U_NET_CSOCK</a>, &amp;a));

    <span class="keywordflow">for</span> (;;)
    {
        <span class="comment">// sleep some time </span>
        (void) <a class="code" href="group__misc.html#gae7bacf8702873ee027691ca4a226d161" title="sleep(3) wrapper that handles EINTR">u_sleep</a>(SOME_TIME);

        <span class="comment">// connect to the server host, reusing the same address</span>
        dbg_ifb ((csd = <a class="code" href="group__net.html#gacd8d6079b2479630c80841b2c3719231" title="Wrapper to u_net_sd_by_addr_ex() with no timeout.">u_net_sd_by_addr</a>(a)) == -1)
            continue;

        <span class="comment">// do some messaging over the connected socket</span>
        dbg_if (do_io(csd));
    }
</pre></div><p>The net module primarily aims at simplifying the socket creation process. When you receive back your brand new socket descriptor, its goal is almost done. You can use libu's <a class="el" href="group__misc.html#ga1466c63f9aba9b5dc6222d2de69229b9" title="An u_io wrapper that uses read(2) as I/O driver.">u_read</a>, <a class="el" href="group__misc.html#gaafa158eeb7326dab36722c1b53f3cf97" title="An u_io wrapper that uses write(2) as I/O driver.">u_write</a>, <a class="el" href="group__net.html#gac108969a701e7bda4927c03d47546459" title="Try to read a chunk of nbytes data from descriptor sd.">u_net_readn</a>, <a class="el" href="group__net.html#ga4f29022971a1ea12af1bf16e197d5099" title="Try to write a chunk of nbytes data to descriptor sd.">u_net_writen</a> or barebones <code>sendto(2)</code>, <code>select(2)</code>, <code>recvmsg(2)</code>, as much as you like. One of my favourite is to use it in association with <a href="http://www.monkey.org/~provos/libevent">libevent</a>. </p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa350157fced1b13c5961eb1f65d70e4a"></a><!-- doxytag: member="net::U_NET_BACKLOG" ref="gaa350157fced1b13c5961eb1f65d70e4a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaa350157fced1b13c5961eb1f65d70e4a">U_NET_BACKLOG</a>&nbsp;&nbsp;&nbsp;300</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default backlog queue size supplied to listen(2). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3123014cf80f1316383db06b6628fe84"></a><!-- doxytag: member="net::u_net_write" ref="ga3123014cf80f1316383db06b6628fe84" args="(sd, buf, nbytes, nw, iseof)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga3123014cf80f1316383db06b6628fe84">u_net_write</a>(sd, buf, nbytes, nw, iseof)&nbsp;&nbsp;&nbsp;u_io((<a class="el" href="group__misc.html#ga38346827c811357bae33fed86a2d4a06">iof_t</a>) write, sd, buf, nbytes, nw, iseof)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__misc.html#gab0e8ac67baec50cb50e91adeb0d14063" title="Top level I/O routine.">u_io</a> specialisation for output ops <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2179c501cfb1200ae5a1a208fef23ce8"></a><!-- doxytag: member="net::u_net_read" ref="ga2179c501cfb1200ae5a1a208fef23ce8" args="(sd, buf, nbytes, nr, iseof)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga2179c501cfb1200ae5a1a208fef23ce8">u_net_read</a>(sd, buf, nbytes, nr, iseof)&nbsp;&nbsp;&nbsp;u_io(read, sd, buf, nbytes, nr, iseof)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="group__misc.html#gab0e8ac67baec50cb50e91adeb0d14063" title="Top level I/O routine.">u_io</a> specialisation for input ops <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f29022971a1ea12af1bf16e197d5099"></a><!-- doxytag: member="net::u_net_writen" ref="ga4f29022971a1ea12af1bf16e197d5099" args="(sd, buf, nbytes)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga4f29022971a1ea12af1bf16e197d5099">u_net_writen</a>(sd, buf, nbytes)&nbsp;&nbsp;&nbsp;u_io((<a class="el" href="group__misc.html#ga38346827c811357bae33fed86a2d4a06">iof_t</a>) write, sd, buf, nbytes, NULL, NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to write a chunk of <code>nbytes</code> data to descriptor <code>sd</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac108969a701e7bda4927c03d47546459"></a><!-- doxytag: member="net::u_net_readn" ref="gac108969a701e7bda4927c03d47546459" args="(sd, buf, nbytes)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac108969a701e7bda4927c03d47546459">u_net_readn</a>(sd, buf, nbytes)&nbsp;&nbsp;&nbsp;u_io(read, sd, buf, nbytes, NULL, NULL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to read a chunk of <code>nbytes</code> data from descriptor <code>sd</code>. <br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga39d477fcf6a0b1618db7b6eafa361750"></a><!-- doxytag: member="net::u_net_addr_t" ref="ga39d477fcf6a0b1618db7b6eafa361750" args="" -->
typedef struct u_net_addr_s&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base type of the net module: holds all the addressing and semantics information needed when creating the corresponding socket. <br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga0e2b0aab1583067ab279f8d3ceacf2c3">u_net_mode_t</a> { <a class="el" href="group__net.html#gga0e2b0aab1583067ab279f8d3ceacf2c3a771100a6478c29b42e870aad0c3b5f08">U_NET_SSOCK</a> =  0, 
<a class="el" href="group__net.html#gga0e2b0aab1583067ab279f8d3ceacf2c3a727f38a9217dbe236a5fe0fe95357ce2">U_NET_CSOCK</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Socket creation semantics: passive or active, i.e. the <code>mode</code> in <a class="el" href="group__net.html#gabf242ab2c9cc25cebafb496e0f5a5bb5" title="Wrapper to u_net_sd_ex() with no timeout.">u_net_sd</a> and <a class="el" href="group__net.html#gaccf28473916f348ca587c535954504ff" title="Parse the supplied uri and transform it into an u_net_addr_t .">u_net_uri2addr</a>. </p>
 <a href="group__net.html#ga0e2b0aab1583067ab279f8d3ceacf2c3">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaa8bfaf677ecbda7099a62a8d85df81f7">u_net_opts_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7ad1538a79a557836493f535ad191df7fd">U_NET_OPT_DONT_REUSE_ADDR</a> =  (1 &lt;&lt; 0), 
<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7ac4ab57cf9a8c45ee977fbec5207968bb">U_NET_OPT_DONT_CONNECT</a> =  (1 &lt;&lt; 1), 
<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7ac3a69622e3d6c2c8eb93b6a063272310">U_NET_OPT_SCTP_ONE_TO_MANY</a> =  (1 &lt;&lt; 2), 
<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7ac6faf9b9cc1dceb030d1bdaca75f7092">U_NET_OPT_SCTP_DATA_IO_EVENT</a> =  (1 &lt;&lt; 3), 
<br/>
&nbsp;&nbsp;<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7a81c94bee0ef0386274379425de821da3">U_NET_OPT_SCTP_ASSOCIATION_EVENT</a> =  (1 &lt;&lt; 4), 
<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7a4b281b16274959fc4b632015e188b063">U_NET_OPT_SCTP_ADDRESS_EVENT</a> =  (1 &lt;&lt; 5), 
<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7ad73f00b4618a76929bc17b45517c2d1a">U_NET_OPT_SCTP_SEND_FAILURE_EVENT</a> =  (1 &lt;&lt; 6), 
<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7afb98072880279853cb7b4817ea1786c5">U_NET_OPT_SCTP_PEER_ERROR_EVENT</a> =  (1 &lt;&lt; 7), 
<br/>
&nbsp;&nbsp;<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7ae1b3ec38c19506f53d506e0596446ba9">U_NET_OPT_SCTP_SHUTDOWN_EVENT</a> =  (1 &lt;&lt; 8), 
<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7a00b80e8c0b7fb1f2906f8ab4cd4c8192">U_NET_OPT_SCTP_PARTIAL_DELIVERY_EVENT</a> =  (1 &lt;&lt; 9), 
<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7ae06d3546d58bcf062bce3f99a8de162c">U_NET_OPT_SCTP_ADAPTATION_LAYER_EVENT</a> =  (1 &lt;&lt; 10), 
<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7a1e5db1f980f40601d74dc769a7a193e6">U_NET_OPT_SCTP_AUTHENTICATION_EVENT</a> =  (1 &lt;&lt; 11), 
<br/>
&nbsp;&nbsp;<a class="el" href="group__net.html#ggaa8bfaf677ecbda7099a62a8d85df81f7a7f75bff4ecf423e1d9903dc3625137f4">U_NET_OPT_DGRAM_BROADCAST</a> =  (1 &lt;&lt; 20)
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Address options, can be supplied (by or'ing them together through <a class="el" href="group__net.html#ga13d154873f3cd691b21250dc99e2be8d" title="Set the supplied address&#39; options to opts.">u_net_addr_set_opts</a> and/or <a class="el" href="group__net.html#ga184b7a1797892fd2397568d389a021ba" title="Add the supplied opts to the given address.">u_net_addr_add_opts</a>, in order to tweek the socket creation machinery. </p>
 <a href="group__net.html#gaa8bfaf677ecbda7099a62a8d85df81f7">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaccf28473916f348ca587c535954504ff">u_net_uri2addr</a> (const char *uri, <a class="el" href="group__net.html#ga0e2b0aab1583067ab279f8d3ceacf2c3">u_net_mode_t</a> mode, <a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> **pa)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse the supplied uri and transform it into an <em>u_net_addr_t</em> .  <a href="#gaccf28473916f348ca587c535954504ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga75904105f0b65d73293523801f9ba2b9">u_net_sd_by_addr_ex</a> (<a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> *a, struct timeval *timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a socket (connected or passive) from a given <a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750" title="Base type of the net module: holds all the addressing and semantics information needed...">u_net_addr_t</a> object.  <a href="#ga75904105f0b65d73293523801f9ba2b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacd8d6079b2479630c80841b2c3719231"></a><!-- doxytag: member="net::u_net_sd_by_addr" ref="gacd8d6079b2479630c80841b2c3719231" args="(u_net_addr_t *a)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gacd8d6079b2479630c80841b2c3719231">u_net_sd_by_addr</a> (<a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> *a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper to <a class="el" href="group__net.html#ga75904105f0b65d73293523801f9ba2b9" title="Create a socket (connected or passive) from a given u_net_addr_t object.">u_net_sd_by_addr_ex()</a> with no timeout. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga52152167b065d3959efe91543012dea9">u_net_sd_ex</a> (const char *uri, <a class="el" href="group__net.html#ga0e2b0aab1583067ab279f8d3ceacf2c3">u_net_mode_t</a> mode, int opts, struct timeval *timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimalistic, one-shot interface which wraps <a class="el" href="group__net.html#gaccf28473916f348ca587c535954504ff" title="Parse the supplied uri and transform it into an u_net_addr_t .">u_net_uri2addr</a>, <a class="el" href="group__net.html#ga13d154873f3cd691b21250dc99e2be8d" title="Set the supplied address&#39; options to opts.">u_net_addr_set_opts</a> and <a class="el" href="group__net.html#gacd8d6079b2479630c80841b2c3719231" title="Wrapper to u_net_sd_by_addr_ex() with no timeout.">u_net_sd_by_addr</a> bits together.  <a href="#ga52152167b065d3959efe91543012dea9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabf242ab2c9cc25cebafb496e0f5a5bb5"></a><!-- doxytag: member="net::u_net_sd" ref="gabf242ab2c9cc25cebafb496e0f5a5bb5" args="(const char *uri, u_net_mode_t mode, int opts)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gabf242ab2c9cc25cebafb496e0f5a5bb5">u_net_sd</a> (const char *uri, <a class="el" href="group__net.html#ga0e2b0aab1583067ab279f8d3ceacf2c3">u_net_mode_t</a> mode, int opts)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper to <a class="el" href="group__net.html#ga52152167b065d3959efe91543012dea9" title="Minimalistic, one-shot interface which wraps u_net_uri2addr, u_net_addr_set_opts...">u_net_sd_ex()</a> with no timeout. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga3c8409a55decafa7d10a93725b7873d6">u_net_addr_can_accept</a> (<a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> *a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell if the supplied address is entitled to call accept(2).  <a href="#ga3c8409a55decafa7d10a93725b7873d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga13d154873f3cd691b21250dc99e2be8d">u_net_addr_set_opts</a> (<a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> *a, int opts)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the supplied address' options to <code>opts</code>.  <a href="#ga13d154873f3cd691b21250dc99e2be8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga184b7a1797892fd2397568d389a021ba">u_net_addr_add_opts</a> (<a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> *a, int opts)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add the supplied <code>opts</code> to the given address.  <a href="#ga184b7a1797892fd2397568d389a021ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga0d63935f837a4d48bcdf29cad218c8b9">u_net_addr_free</a> (<a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> *a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory allocated to an <a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750" title="Base type of the net module: holds all the addressing and semantics information needed...">u_net_addr_t</a> object.  <a href="#ga0d63935f837a4d48bcdf29cad218c8b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf9ec5224c6979e3e3ff7ef267d2fe55f"></a><!-- doxytag: member="net::u_accept" ref="gaf9ec5224c6979e3e3ff7ef267d2fe55f" args="(int sd, struct sockaddr *addr, u_socklen_t *addrlen)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaf9ec5224c6979e3e3ff7ef267d2fe55f">u_accept</a> (int sd, struct sockaddr *addr, u_socklen_t *addrlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">accept(2) wrapper that handles <code>EINTR</code> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac18f2db2f80ce21ac6394f18d0b2c787"></a><!-- doxytag: member="net::u_socket" ref="gac18f2db2f80ce21ac6394f18d0b2c787" args="(int domain, int type, int protocol)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac18f2db2f80ce21ac6394f18d0b2c787">u_socket</a> (int domain, int type, int protocol)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">socket(2) wrapper <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa2404c5c156bd1e28c333718e611365a"></a><!-- doxytag: member="net::u_connect" ref="gaa2404c5c156bd1e28c333718e611365a" args="(int sd, const struct sockaddr *addr, u_socklen_t addrlen)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaa2404c5c156bd1e28c333718e611365a">u_connect</a> (int sd, const struct sockaddr *addr, u_socklen_t addrlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper to <a class="el" href="group__net.html#gacde21ad00225024ca0b40800b5897e63" title="timeouted connect(2) wrapper that handles EINTR ">u_connect_ex</a> with no timeout. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gacde21ad00225024ca0b40800b5897e63">u_connect_ex</a> (int sd, const struct sockaddr *addr, u_socklen_t addrlen, struct timeval *timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">timeouted connect(2) wrapper that handles <code>EINTR</code>  <a href="#gacde21ad00225024ca0b40800b5897e63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5814847b4338ce43c41c9f138c62ba13"></a><!-- doxytag: member="net::u_bind" ref="ga5814847b4338ce43c41c9f138c62ba13" args="(int sd, const struct sockaddr *addr, u_socklen_t addrlen)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga5814847b4338ce43c41c9f138c62ba13">u_bind</a> (int sd, const struct sockaddr *addr, u_socklen_t addrlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bind(2) wrapper <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad55a7cd58e1f075ea9da27260c90ea08"></a><!-- doxytag: member="net::u_listen" ref="gad55a7cd58e1f075ea9da27260c90ea08" args="(int sd, int backlog)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gad55a7cd58e1f075ea9da27260c90ea08">u_listen</a> (int sd, int backlog)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">listen(2) wrapper <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3507189f3504b9baa4ae475a30a3d40"></a><!-- doxytag: member="net::u_setsockopt" ref="gaf3507189f3504b9baa4ae475a30a3d40" args="(int sd, int lev, int name, const void *val, u_socklen_t len)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaf3507189f3504b9baa4ae475a30a3d40">u_setsockopt</a> (int sd, int lev, int name, const void *val, u_socklen_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">setsockopt(2) wrapper <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac4b2073f80070769d0ff31ec017d4e63"></a><!-- doxytag: member="net::u_getsockopt" ref="gac4b2073f80070769d0ff31ec017d4e63" args="(int sd, int lev, int name, void *val, u_socklen_t *len)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gac4b2073f80070769d0ff31ec017d4e63">u_getsockopt</a> (int sd, int lev, int name, void *val, u_socklen_t *len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">getsockopt(2) wrapper <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gaeaed27b44ad610f971e43eb30f106022">u_net_set_nonblocking</a> (int s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark the supplied socket descriptor as non-blocking.  <a href="#gaeaed27b44ad610f971e43eb30f106022"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga69f2297b2d2af55fbe268bec0dd98948">u_net_unset_nonblocking</a> (int s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unset the non-blocking bit on the supplied socket descriptor.  <a href="#ga69f2297b2d2af55fbe268bec0dd98948"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#ga4c5da21ffb46f38f0f9d3839f882d6b4">u_net_nagle_off</a> (int s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable Nagle algorithm on the supplied TCP socket.  <a href="#ga4c5da21ffb46f38f0f9d3839f882d6b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafb9ef2a7c75952061e96968cc167bbba"></a><!-- doxytag: member="net::u_inet_ntop" ref="gafb9ef2a7c75952061e96968cc167bbba" args="(int af, const void *src, char *dst, u_socklen_t len)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gafb9ef2a7c75952061e96968cc167bbba">u_inet_ntop</a> (int af, const void *src, char *dst, u_socklen_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper to inet_ntop(3). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae27b64ac5355ba7b826f1827b9bf665e"></a><!-- doxytag: member="net::u_sa_ntop" ref="gae27b64ac5355ba7b826f1827b9bf665e" args="(const struct sockaddr *sa, char *d, size_t dlen)" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net.html#gae27b64ac5355ba7b826f1827b9bf665e">u_sa_ntop</a> (const struct sockaddr *sa, char *d, size_t dlen)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pretty print the given sockaddr (path, or address and port). <br/></td></tr>
</table>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga0e2b0aab1583067ab279f8d3ceacf2c3"></a><!-- doxytag: member="net.h::u_net_mode_t" ref="ga0e2b0aab1583067ab279f8d3ceacf2c3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__net.html#ga0e2b0aab1583067ab279f8d3ceacf2c3">u_net_mode_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga0e2b0aab1583067ab279f8d3ceacf2c3a771100a6478c29b42e870aad0c3b5f08"></a><!-- doxytag: member="U_NET_SSOCK" ref="gga0e2b0aab1583067ab279f8d3ceacf2c3a771100a6478c29b42e870aad0c3b5f08" args="" -->U_NET_SSOCK</em>&nbsp;</td><td>
<p>the address is used for a passive socket </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0e2b0aab1583067ab279f8d3ceacf2c3a727f38a9217dbe236a5fe0fe95357ce2"></a><!-- doxytag: member="U_NET_CSOCK" ref="gga0e2b0aab1583067ab279f8d3ceacf2c3a727f38a9217dbe236a5fe0fe95357ce2" args="" -->U_NET_CSOCK</em>&nbsp;</td><td>
<p>the address is used for an active socket </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="net_8h_source.html#l00087">87</a> of file <a class="el" href="net_8h_source.html">net.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa8bfaf677ecbda7099a62a8d85df81f7"></a><!-- doxytag: member="net.h::u_net_opts_t" ref="gaa8bfaf677ecbda7099a62a8d85df81f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__net.html#gaa8bfaf677ecbda7099a62a8d85df81f7">u_net_opts_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7ad1538a79a557836493f535ad191df7fd"></a><!-- doxytag: member="U_NET_OPT_DONT_REUSE_ADDR" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7ad1538a79a557836493f535ad191df7fd" args="" -->U_NET_OPT_DONT_REUSE_ADDR</em>&nbsp;</td><td>
<p>Disable local address reuse when creating a passive socket </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7ac4ab57cf9a8c45ee977fbec5207968bb"></a><!-- doxytag: member="U_NET_OPT_DONT_CONNECT" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7ac4ab57cf9a8c45ee977fbec5207968bb" args="" -->U_NET_OPT_DONT_CONNECT</em>&nbsp;</td><td>
<p>Do not <code>connect(2)</code> when creating an (UDP) active socket </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7ac3a69622e3d6c2c8eb93b6a063272310"></a><!-- doxytag: member="U_NET_OPT_SCTP_ONE_TO_MANY" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7ac3a69622e3d6c2c8eb93b6a063272310" args="" -->U_NET_OPT_SCTP_ONE_TO_MANY</em>&nbsp;</td><td>
<p>Use one-to-many model when creating SCTP sockets </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7ac6faf9b9cc1dceb030d1bdaca75f7092"></a><!-- doxytag: member="U_NET_OPT_SCTP_DATA_IO_EVENT" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7ac6faf9b9cc1dceb030d1bdaca75f7092" args="" -->U_NET_OPT_SCTP_DATA_IO_EVENT</em>&nbsp;</td><td>
<p>SCTP only: get extra information as ancillary data with the receive calls, e.g. the stream number </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7a81c94bee0ef0386274379425de821da3"></a><!-- doxytag: member="U_NET_OPT_SCTP_ASSOCIATION_EVENT" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7a81c94bee0ef0386274379425de821da3" args="" -->U_NET_OPT_SCTP_ASSOCIATION_EVENT</em>&nbsp;</td><td>
<p>SCTP only: get notification about changes in associations, including the arrival of new associations </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7a4b281b16274959fc4b632015e188b063"></a><!-- doxytag: member="U_NET_OPT_SCTP_ADDRESS_EVENT" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7a4b281b16274959fc4b632015e188b063" args="" -->U_NET_OPT_SCTP_ADDRESS_EVENT</em>&nbsp;</td><td>
<p>SCTP only: get notfication when some event occurs concerning one of the peer's addresses, e.g. addition, deletion, reachability, unreachability </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7ad73f00b4618a76929bc17b45517c2d1a"></a><!-- doxytag: member="U_NET_OPT_SCTP_SEND_FAILURE_EVENT" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7ad73f00b4618a76929bc17b45517c2d1a" args="" -->U_NET_OPT_SCTP_SEND_FAILURE_EVENT</em>&nbsp;</td><td>
<p>SCTP only: when a send fails, the data is returned with an error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7afb98072880279853cb7b4817ea1786c5"></a><!-- doxytag: member="U_NET_OPT_SCTP_PEER_ERROR_EVENT" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7afb98072880279853cb7b4817ea1786c5" args="" -->U_NET_OPT_SCTP_PEER_ERROR_EVENT</em>&nbsp;</td><td>
<p>SCTP only: get peer error messages (as TLV) from the stack </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7ae1b3ec38c19506f53d506e0596446ba9"></a><!-- doxytag: member="U_NET_OPT_SCTP_SHUTDOWN_EVENT" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7ae1b3ec38c19506f53d506e0596446ba9" args="" -->U_NET_OPT_SCTP_SHUTDOWN_EVENT</em>&nbsp;</td><td>
<p>SCTP only: get notifications about the peer having closed or shutdown an association </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7a00b80e8c0b7fb1f2906f8ab4cd4c8192"></a><!-- doxytag: member="U_NET_OPT_SCTP_PARTIAL_DELIVERY_EVENT" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7a00b80e8c0b7fb1f2906f8ab4cd4c8192" args="" -->U_NET_OPT_SCTP_PARTIAL_DELIVERY_EVENT</em>&nbsp;</td><td>
<p>SCTP only: get notified about issues that may occur in the partial delivery API </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7ae06d3546d58bcf062bce3f99a8de162c"></a><!-- doxytag: member="U_NET_OPT_SCTP_ADAPTATION_LAYER_EVENT" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7ae06d3546d58bcf062bce3f99a8de162c" args="" -->U_NET_OPT_SCTP_ADAPTATION_LAYER_EVENT</em>&nbsp;</td><td>
<p>SCTP only: get events coming from the adaptation layer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7a1e5db1f980f40601d74dc769a7a193e6"></a><!-- doxytag: member="U_NET_OPT_SCTP_AUTHENTICATION_EVENT" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7a1e5db1f980f40601d74dc769a7a193e6" args="" -->U_NET_OPT_SCTP_AUTHENTICATION_EVENT</em>&nbsp;</td><td>
<p>SCTP only: get authentication events, e.g. activation of new keys </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaa8bfaf677ecbda7099a62a8d85df81f7a7f75bff4ecf423e1d9903dc3625137f4"></a><!-- doxytag: member="U_NET_OPT_DGRAM_BROADCAST" ref="ggaa8bfaf677ecbda7099a62a8d85df81f7a7f75bff4ecf423e1d9903dc3625137f4" args="" -->U_NET_OPT_DGRAM_BROADCAST</em>&nbsp;</td><td>
<p>DGRAM only: automatically sets broadcast option in client socket using setsockopt() </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="net_8h_source.html#l00097">97</a> of file <a class="el" href="net_8h_source.html">net.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gacde21ad00225024ca0b40800b5897e63"></a><!-- doxytag: member="net.c::u_connect_ex" ref="gacde21ad00225024ca0b40800b5897e63" args="(int sd, const struct sockaddr *addr, u_socklen_t addrlen, struct timeval *timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int u_connect_ex </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_socklen_t&nbsp;</td>
          <td class="paramname"> <em>addrlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Timeouted connect(2) wrapper that handles <code>EINTR</code>. In case the underlying select(2) is interrupted by a trapped signal, the object pointed to by the <code>timeout</code> argument may be modified, so it's safer to explicitly reinitialize it for any subsequent use.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sd</em>&nbsp;</td><td>socket descriptor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>address of the peer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addrlen</em>&nbsp;</td><td>size of <code>addr</code> in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>if non-NULL specifies a maximum interval to wait for the connection attempt to complete. If a NULL value is supplied the default platform timeout is in place.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>generic error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-2</em>&nbsp;</td><td>timeout </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="net_8c_source.html#l00496">496</a> of file <a class="el" href="net_8c_source.html">net.c</a>.</p>

<p>References <a class="el" href="net_8c_source.html#l00643">u_getsockopt()</a>, <a class="el" href="net_8c_source.html#l00670">u_net_set_nonblocking()</a>, and <a class="el" href="net_8c_source.html#l00694">u_net_unset_nonblocking()</a>.</p>

<p>Referenced by <a class="el" href="net_8c_source.html#l00472">u_connect()</a>.</p>

</div>
</div>
<a class="anchor" id="ga184b7a1797892fd2397568d389a021ba"></a><!-- doxytag: member="net.c::u_net_addr_add_opts" ref="ga184b7a1797892fd2397568d389a021ba" args="(u_net_addr_t *a, int opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void u_net_addr_add_opts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the supplied options set <code>opts</code> to <code>a</code> options' set. This operation is not disruptive so that any option that was previously installed in the address is retained.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>an already allocated <a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750" title="Base type of the net module: holds all the addressing and semantics information needed...">u_net_addr_t</a> object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>the set of options that will added to the set of options already installed</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>nothing </dd></dl>

<p>Definition at line <a class="el" href="net_8c_source.html#l00408">408</a> of file <a class="el" href="net_8c_source.html">net.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c8409a55decafa7d10a93725b7873d6"></a><!-- doxytag: member="net.c::u_net_addr_can_accept" ref="ga3c8409a55decafa7d10a93725b7873d6" args="(u_net_addr_t *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int u_net_addr_can_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>A <a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750" title="Base type of the net module: holds all the addressing and semantics information needed...">u_net_addr_t</a> object that has been created via <a class="el" href="group__net.html#gaccf28473916f348ca587c535954504ff" title="Parse the supplied uri and transform it into an u_net_addr_t .">u_net_uri2addr</a></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>1</em>&nbsp;</td><td>if the address is suitable for accept'ing connections </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if the address is invalid, or not eligible for accept(2) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="net_8c_source.html#l00361">361</a> of file <a class="el" href="net_8c_source.html">net.c</a>.</p>

<p>References <a class="el" href="net_8h_source.html#l00088">U_NET_SSOCK</a>.</p>

</div>
</div>
<a class="anchor" id="ga0d63935f837a4d48bcdf29cad218c8b9"></a><!-- doxytag: member="net.c::u_net_addr_free" ref="ga0d63935f837a4d48bcdf29cad218c8b9" args="(u_net_addr_t *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void u_net_addr_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free resources allocated to the previously allocated <a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750" title="Base type of the net module: holds all the addressing and semantics information needed...">u_net_addr_t</a> object <code>a</code>. A new <a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750" title="Base type of the net module: holds all the addressing and semantics information needed...">u_net_addr_t</a> object is created at each <a class="el" href="group__net.html#gaccf28473916f348ca587c535954504ff" title="Parse the supplied uri and transform it into an u_net_addr_t .">u_net_uri2addr</a> invocation and must be explicitly released, otherwise it'll be leaked.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>nothing </dd></dl>

<p>Definition at line <a class="el" href="net_8c_source.html#l00425">425</a> of file <a class="el" href="net_8c_source.html">net.c</a>.</p>

<p>References <a class="el" href="memory_8c_source.html#l00085">u_free()</a>.</p>

<p>Referenced by <a class="el" href="net_8c_source.html#l00312">u_net_sd_ex()</a>, and <a class="el" href="net_8c_source.html#l00228">u_net_uri2addr()</a>.</p>

</div>
</div>
<a class="anchor" id="ga13d154873f3cd691b21250dc99e2be8d"></a><!-- doxytag: member="net.c::u_net_addr_set_opts" ref="ga13d154873f3cd691b21250dc99e2be8d" args="(u_net_addr_t *a, int opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void u_net_addr_set_opts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Install the supplied options set <code>opts</code> into the address pointed by <code>a</code>. Beware that this operation overrides any option that was previously installed in the address.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>an already allocated <a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750" title="Base type of the net module: holds all the addressing and semantics information needed...">u_net_addr_t</a> object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>the set of options that will be installed</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>nothing </dd></dl>

<p>Definition at line <a class="el" href="net_8c_source.html#l00388">388</a> of file <a class="el" href="net_8c_source.html">net.c</a>.</p>

<p>Referenced by <a class="el" href="net_8c_source.html#l00312">u_net_sd_ex()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4c5da21ffb46f38f0f9d3839f882d6b4"></a><!-- doxytag: member="net.c::u_net_nagle_off" ref="ga4c5da21ffb46f38f0f9d3839f882d6b4" args="(int s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int u_net_nagle_off </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>a TCP socket descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if successful or <code>TCP_NODELAY</code> not implemented </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>~0</em>&nbsp;</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="net_8c_source.html#l00719">719</a> of file <a class="el" href="net_8c_source.html">net.c</a>.</p>

<p>References <a class="el" href="net_8c_source.html#l00623">u_setsockopt()</a>.</p>

</div>
</div>
<a class="anchor" id="ga75904105f0b65d73293523801f9ba2b9"></a><!-- doxytag: member="net.c::u_net_sd_by_addr_ex" ref="ga75904105f0b65d73293523801f9ba2b9" args="(u_net_addr_t *a, struct timeval *timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int u_net_sd_by_addr_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a socket, being connected or passive depends on <code>mode</code> value, given the already filled-in <a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750" title="Base type of the net module: holds all the addressing and semantics information needed...">u_net_addr_t</a> object <code>a</code>. The returned socket descriptor can then be used for any I/O operation compatible with its underlying nature.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>a valid <a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750" title="Base type of the net module: holds all the addressing and semantics information needed...">u_net_addr_t</a> address, created by a previous call to <a class="el" href="group__net.html#gaccf28473916f348ca587c535954504ff" title="Parse the supplied uri and transform it into an u_net_addr_t .">u_net_uri2addr</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>maximum time to wait for connection</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the created socket descriptor, or <code>-1</code> on error. </dd></dl>

<p>Definition at line <a class="el" href="net_8c_source.html#l00278">278</a> of file <a class="el" href="net_8c_source.html">net.c</a>.</p>

<p>References <a class="el" href="net_8h_source.html#l00075">U_NET_BACKLOG</a>, <a class="el" href="net_8h_source.html#l00089">U_NET_CSOCK</a>, and <a class="el" href="net_8h_source.html#l00088">U_NET_SSOCK</a>.</p>

<p>Referenced by <a class="el" href="net_8c_source.html#l00296">u_net_sd_by_addr()</a>, and <a class="el" href="net_8c_source.html#l00312">u_net_sd_ex()</a>.</p>

</div>
</div>
<a class="anchor" id="ga52152167b065d3959efe91543012dea9"></a><!-- doxytag: member="net.c::u_net_sd_ex" ref="ga52152167b065d3959efe91543012dea9" args="(const char *uri, u_net_mode_t mode, int opts, struct timeval *timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int u_net_sd_ex </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net.html#ga0e2b0aab1583067ab279f8d3ceacf2c3">u_net_mode_t</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uri</em>&nbsp;</td><td>an URI string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>one of <a class="el" href="group__net.html#gga0e2b0aab1583067ab279f8d3ceacf2c3a727f38a9217dbe236a5fe0fe95357ce2">U_NET_CSOCK</a> (connected) or <a class="el" href="group__net.html#gga0e2b0aab1583067ab279f8d3ceacf2c3a771100a6478c29b42e870aad0c3b5f08">U_NET_SSOCK</a> (passive) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>set of OR'd <code>U_NET_OPT_*</code> bits </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>maximum time to wait for connection</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created socket descriptor, or <code>-1</code> on error. </dd></dl>

<p>Definition at line <a class="el" href="net_8c_source.html#l00312">312</a> of file <a class="el" href="net_8c_source.html">net.c</a>.</p>

<p>References <a class="el" href="net_8c_source.html#l00425">u_net_addr_free()</a>, <a class="el" href="net_8c_source.html#l00388">u_net_addr_set_opts()</a>, <a class="el" href="net_8c_source.html#l00278">u_net_sd_by_addr_ex()</a>, and <a class="el" href="net_8c_source.html#l00228">u_net_uri2addr()</a>.</p>

<p>Referenced by <a class="el" href="net_8c_source.html#l00347">u_net_sd()</a>.</p>

</div>
</div>
<a class="anchor" id="gaeaed27b44ad610f971e43eb30f106022"></a><!-- doxytag: member="net.c::u_net_set_nonblocking" ref="gaeaed27b44ad610f971e43eb30f106022" args="(int s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int u_net_set_nonblocking </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>a TCP socket descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if successful </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>~0</em>&nbsp;</td><td>on error or fcntl(2) not implemented </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="net_8c_source.html#l00670">670</a> of file <a class="el" href="net_8c_source.html">net.c</a>.</p>

<p>Referenced by <a class="el" href="net_8c_source.html#l00496">u_connect_ex()</a>.</p>

</div>
</div>
<a class="anchor" id="ga69f2297b2d2af55fbe268bec0dd98948"></a><!-- doxytag: member="net.c::u_net_unset_nonblocking" ref="ga69f2297b2d2af55fbe268bec0dd98948" args="(int s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int u_net_unset_nonblocking </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>a TCP socket descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if successful </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>~0</em>&nbsp;</td><td>on error or fcntl(2) not implemented </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="net_8c_source.html#l00694">694</a> of file <a class="el" href="net_8c_source.html">net.c</a>.</p>

<p>Referenced by <a class="el" href="net_8c_source.html#l00496">u_connect_ex()</a>.</p>

</div>
</div>
<a class="anchor" id="gaccf28473916f348ca587c535954504ff"></a><!-- doxytag: member="net.c::u_net_uri2addr" ref="gaccf28473916f348ca587c535954504ff" args="(const char *uri, u_net_mode_t mode, u_net_addr_t **pa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int u_net_uri2addr </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net.html#ga0e2b0aab1583067ab279f8d3ceacf2c3">u_net_mode_t</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750">u_net_addr_t</a> **&nbsp;</td>
          <td class="paramname"> <em>pa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse the supplied <code>uri</code> string and return an <a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750" title="Base type of the net module: holds all the addressing and semantics information needed...">u_net_addr_t</a> object at <code>pa</code> as a result argument. The address can then be used (and reused) to create passive or connected sockets by means of the <a class="el" href="group__net.html#gacd8d6079b2479630c80841b2c3719231" title="Wrapper to u_net_sd_by_addr_ex() with no timeout.">u_net_sd_by_addr</a> interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>uri</em>&nbsp;</td><td>an URI string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>one of <a class="el" href="group__net.html#gga0e2b0aab1583067ab279f8d3ceacf2c3a771100a6478c29b42e870aad0c3b5f08">U_NET_SSOCK</a> if the address needs to be used for a passive socket, or <a class="el" href="group__net.html#gga0e2b0aab1583067ab279f8d3ceacf2c3a727f38a9217dbe236a5fe0fe95357ce2">U_NET_CSOCK</a> if the address will be used for a connected (i.e. non-passive) socket </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pa</em>&nbsp;</td><td>the translated <a class="el" href="group__net.html#ga39d477fcf6a0b1618db7b6eafa361750" title="Base type of the net module: holds all the addressing and semantics information needed...">u_net_addr_t</a> as a result argument</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>~0</em>&nbsp;</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="net_8c_source.html#l00228">228</a> of file <a class="el" href="net_8c_source.html">net.c</a>.</p>

<p>References <a class="el" href="net_8c_source.html#l00425">u_net_addr_free()</a>, <a class="el" href="srcs_2toolbox_2uri_8c_source.html#l00125">u_uri_crumble()</a>, <a class="el" href="srcs_2toolbox_2uri_8c_source.html#l00275">u_uri_free()</a>, <a class="el" href="group__uri.html#gaf9be8344c2ea8f4ecdbc7fd40a7a69f0">u_uri_get_scheme()</a>, and <a class="el" href="uri_8h_source.html#l00029">U_URI_OPT_NONE</a>.</p>

<p>Referenced by <a class="el" href="net_8c_source.html#l00312">u_net_sd_ex()</a>.</p>

</div>
</div>
</div>
<hr>
<div>
  <div style="text-align:left">
    <a href="http://www.koanlogic.com/products.html">&larr;Products</a>
  </div>
  <div style="text-align:center;">
    &copy; 2005-2012 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
  </div>
</div>

</body>
</html>
