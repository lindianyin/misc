<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LibU: buf.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Intro</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_000000.html">srcs</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_000001.html">toolbox</a>
  </div>
</div>
<div class="contents">
<h1>buf.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* </span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 2005-2012 by KoanLogic s.r.l. - All rights reserved.  </span>
<a name="l00003"></a>00003 <span class="comment"> */</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;u/libu.h&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;toolbox/buf.h&gt;</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="keyword">struct </span>u_buf_s
<a name="l00014"></a>00014 {
<a name="l00015"></a>00015     <span class="keywordtype">char</span> *data;     <span class="comment">/* the memory buffer */</span>
<a name="l00016"></a>00016     <span class="keywordtype">size_t</span> size;    <span class="comment">/* bytes malloc&#39;d for .data */</span>
<a name="l00017"></a>00017     <span class="keywordtype">size_t</span> len;     <span class="comment">/* bytes actually in use (always &lt;= .size) */</span>
<a name="l00018"></a>00018 };
<a name="l00019"></a>00019 
<a name="l00041"></a><a class="code" href="group__buf.html#ga280dd0228033fb8d8ef60051ac211367">00041</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga280dd0228033fb8d8ef60051ac211367" title="Enlarge the memory allocated to a given buffer.">u_buf_reserve</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf, <span class="keywordtype">size_t</span> size)
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043     <span class="keywordtype">char</span> *nbuf;
<a name="l00044"></a>00044 
<a name="l00045"></a>00045     dbg_err_if (ubuf == NULL);
<a name="l00046"></a>00046 
<a name="l00047"></a>00047     nop_return_if (size &lt;= ubuf-&gt;size, 0);  <span class="comment">/* nothing to do */</span>
<a name="l00048"></a>00048    
<a name="l00049"></a>00049     <span class="comment">/* size plus 1 char to store a &#39;\0&#39; */</span>
<a name="l00050"></a>00050     dbg_err_sif ((nbuf = <a class="code" href="group__alloc.html#ga3b9979ee06d0cffdac539b7657298490" title="Wrapper for realloc-like function.">u_realloc</a>(ubuf-&gt;data, size + 1)) == NULL);
<a name="l00051"></a>00051 
<a name="l00052"></a>00052     <span class="comment">/* buffer data will always be zero-terminated (but the len field will not</span>
<a name="l00053"></a>00053 <span class="comment">     * count the last &#39;\0&#39;) */</span>
<a name="l00054"></a>00054     nbuf[size] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00055"></a>00055 
<a name="l00056"></a>00056     ubuf-&gt;data = nbuf;
<a name="l00057"></a>00057     ubuf-&gt;size = size;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059     <span class="keywordflow">return</span> 0;
<a name="l00060"></a>00060 err:
<a name="l00061"></a>00061     <span class="keywordflow">return</span> ~0;
<a name="l00062"></a>00062 }
<a name="l00063"></a>00063 
<a name="l00077"></a><a class="code" href="group__buf.html#ga501453a6972b803dc1b6aee5bbaef2be">00077</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga501453a6972b803dc1b6aee5bbaef2be" title="Append data to the buffer.">u_buf_append</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> size)
<a name="l00078"></a>00078 {
<a name="l00079"></a>00079     dbg_return_if (ubuf == NULL, ~0);
<a name="l00080"></a>00080     dbg_return_if (data == NULL, ~0);
<a name="l00081"></a>00081     dbg_return_if (size == 0, ~0);
<a name="l00082"></a>00082 
<a name="l00083"></a>00083     <span class="keywordflow">if</span> (ubuf-&gt;size - ubuf-&gt;len &lt; size)
<a name="l00084"></a>00084     {
<a name="l00085"></a>00085         <span class="comment">/* buffer too small, resize generously */</span>
<a name="l00086"></a>00086         dbg_err_if (<a class="code" href="group__buf.html#ga280dd0228033fb8d8ef60051ac211367" title="Enlarge the memory allocated to a given buffer.">u_buf_reserve</a>(ubuf, ubuf-&gt;size + ubuf-&gt;len + 2 * size));
<a name="l00087"></a>00087     }
<a name="l00088"></a>00088  
<a name="l00089"></a>00089     memcpy(ubuf-&gt;data + ubuf-&gt;len, data, size);
<a name="l00090"></a>00090     ubuf-&gt;len += size;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     <span class="comment">/* zero term the buffer so it can be used (when applicable) as a string */</span>
<a name="l00093"></a>00093     ubuf-&gt;data[ubuf-&gt;len] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00094"></a>00094 
<a name="l00095"></a>00095     <span class="keywordflow">return</span> 0;
<a name="l00096"></a>00096 err:
<a name="l00097"></a>00097     <span class="keywordflow">return</span> ~0;
<a name="l00098"></a>00098 }
<a name="l00099"></a>00099 
<a name="l00111"></a><a class="code" href="group__buf.html#ga605fc42679dfea4b7231408d6d14e351">00111</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga605fc42679dfea4b7231408d6d14e351" title="Fill a buffer object with the content of a file.">u_buf_load</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf, <span class="keyword">const</span> <span class="keywordtype">char</span> *filename)
<a name="l00112"></a>00112 {
<a name="l00113"></a>00113     <span class="keyword">struct </span>stat st;
<a name="l00114"></a>00114     FILE *fp = NULL;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     dbg_return_if (ubuf == NULL, ~0);
<a name="l00117"></a>00117     dbg_return_if (filename == NULL, ~0);
<a name="l00118"></a>00118 
<a name="l00119"></a>00119     dbg_err_sif (stat(filename, &amp;st) == -1);
<a name="l00120"></a>00120 
<a name="l00121"></a>00121     <span class="comment">/* clear the current data */</span>
<a name="l00122"></a>00122     dbg_err_if (<a class="code" href="group__buf.html#ga127f2540b4a23d06b5b36da537fdc3bb" title="Clear a buffer.">u_buf_clear</a>(ubuf));
<a name="l00123"></a>00123 
<a name="l00124"></a>00124     <span class="comment">/* be sure to have a big enough buffer */</span>
<a name="l00125"></a>00125     dbg_err_if (<a class="code" href="group__buf.html#ga280dd0228033fb8d8ef60051ac211367" title="Enlarge the memory allocated to a given buffer.">u_buf_reserve</a>(ubuf, st.st_size));
<a name="l00126"></a>00126 
<a name="l00127"></a>00127     dbg_err_sifm ((fp = fopen(filename, <span class="stringliteral">&quot;r&quot;</span>)) == NULL, <span class="stringliteral">&quot;%s&quot;</span>, filename);
<a name="l00128"></a>00128 
<a name="l00129"></a>00129     <span class="comment">/* fill the buffer with the whole file content */</span>
<a name="l00130"></a>00130     dbg_err_if (fread(ubuf-&gt;data, st.st_size, 1, fp) != 1);
<a name="l00131"></a>00131     ubuf-&gt;len = st.st_size;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133     (void) fclose(fp);
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     <span class="keywordflow">return</span> 0;
<a name="l00136"></a>00136 err:
<a name="l00137"></a>00137     U_FCLOSE(fp);
<a name="l00138"></a>00138     <span class="keywordflow">return</span> ~0;
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00152"></a><a class="code" href="group__buf.html#ga11b25989e45ded40d397f7596f4d0168">00152</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga11b25989e45ded40d397f7596f4d0168" title="Save buffer to file.">u_buf_save</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf, <span class="keyword">const</span> <span class="keywordtype">char</span> *filename)
<a name="l00153"></a>00153 {
<a name="l00154"></a>00154     dbg_return_if (ubuf == NULL, ~0);
<a name="l00155"></a>00155     dbg_return_if (filename == NULL, ~0);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157     <span class="keywordflow">return</span> <a class="code" href="group__misc.html#ga0e404a403d8b3c4d0083c97d581e4b23" title="Save some data in memory to file.">u_data_dump</a>(<a class="code" href="group__buf.html#ga00f0a98f557b2c4fb42e2f73b5722066" title="Return the pointer to the internal data block.">u_buf_ptr</a>(ubuf), <a class="code" href="group__buf.html#ga9669dec13ecd194d472e85f2cf7828f7" title="Return the number of used bytes in the supplied buffer.">u_buf_len</a>(ubuf), filename);
<a name="l00158"></a>00158 }
<a name="l00159"></a>00159 
<a name="l00174"></a><a class="code" href="group__buf.html#ga41205cb892debc42a36fb7fd54256ae1">00174</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga41205cb892debc42a36fb7fd54256ae1" title="Give up ownership of the u_buf_t data block.">u_buf_detach</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf)
<a name="l00175"></a>00175 {
<a name="l00176"></a>00176     dbg_return_if (ubuf == NULL, ~0);
<a name="l00177"></a>00177 
<a name="l00178"></a>00178     ubuf-&gt;data = NULL;
<a name="l00179"></a>00179     ubuf-&gt;size = 0;
<a name="l00180"></a>00180     ubuf-&gt;len = 0;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182     <span class="keywordflow">return</span> 0;
<a name="l00183"></a>00183 }
<a name="l00184"></a>00184 
<a name="l00197"></a><a class="code" href="group__buf.html#gad08c514dfcb94f5a6661c848b23fdefe">00197</a> ssize_t <a class="code" href="group__buf.html#gad08c514dfcb94f5a6661c848b23fdefe" title="Return the total size of the data block allocated by the buffer.">u_buf_size</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf)
<a name="l00198"></a>00198 {
<a name="l00199"></a>00199     dbg_return_if (ubuf == NULL, -1);
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <span class="keywordflow">return</span> ubuf-&gt;size;
<a name="l00202"></a>00202 }
<a name="l00203"></a>00203 
<a name="l00215"></a><a class="code" href="group__buf.html#ga9669dec13ecd194d472e85f2cf7828f7">00215</a> ssize_t <a class="code" href="group__buf.html#ga9669dec13ecd194d472e85f2cf7828f7" title="Return the number of used bytes in the supplied buffer.">u_buf_len</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf)
<a name="l00216"></a>00216 {
<a name="l00217"></a>00217     dbg_return_if (ubuf == NULL, -1);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219     <span class="keywordflow">return</span> ubuf-&gt;len;
<a name="l00220"></a>00220 }
<a name="l00221"></a>00221 
<a name="l00233"></a><a class="code" href="group__buf.html#ga127f2540b4a23d06b5b36da537fdc3bb">00233</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga127f2540b4a23d06b5b36da537fdc3bb" title="Clear a buffer.">u_buf_clear</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf)
<a name="l00234"></a>00234 {
<a name="l00235"></a>00235     dbg_return_if (ubuf == NULL, ~0);
<a name="l00236"></a>00236     
<a name="l00237"></a>00237     ubuf-&gt;len = 0;
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <span class="keywordflow">return</span> 0;
<a name="l00240"></a>00240 }
<a name="l00241"></a>00241 
<a name="l00257"></a><a class="code" href="group__buf.html#ga638ecb7c989ab2081949d62d6220ce97">00257</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga638ecb7c989ab2081949d62d6220ce97" title="Set the value of a buffer.">u_buf_set</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> size)
<a name="l00258"></a>00258 {
<a name="l00259"></a>00259     dbg_return_if (ubuf == NULL, ~0);
<a name="l00260"></a>00260     dbg_return_if (data == NULL, ~0);
<a name="l00261"></a>00261     dbg_return_if (size == 0, ~0);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263     dbg_err_if (<a class="code" href="group__buf.html#ga127f2540b4a23d06b5b36da537fdc3bb" title="Clear a buffer.">u_buf_clear</a>(ubuf));
<a name="l00264"></a>00264     dbg_err_if (<a class="code" href="group__buf.html#ga501453a6972b803dc1b6aee5bbaef2be" title="Append data to the buffer.">u_buf_append</a>(ubuf, data, size));
<a name="l00265"></a>00265 
<a name="l00266"></a>00266     <span class="keywordflow">return</span> 0;
<a name="l00267"></a>00267 err:
<a name="l00268"></a>00268     <span class="keywordflow">return</span> ~0;
<a name="l00269"></a>00269 }
<a name="l00270"></a>00270 
<a name="l00282"></a><a class="code" href="group__buf.html#ga00f0a98f557b2c4fb42e2f73b5722066">00282</a> <span class="keywordtype">void</span> *<a class="code" href="group__buf.html#ga00f0a98f557b2c4fb42e2f73b5722066" title="Return the pointer to the internal data block.">u_buf_ptr</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf)
<a name="l00283"></a>00283 {
<a name="l00284"></a>00284     dbg_return_if (ubuf == NULL, NULL);
<a name="l00285"></a>00285     
<a name="l00286"></a>00286     <span class="keywordflow">return</span> ubuf-&gt;data;
<a name="l00287"></a>00287 }
<a name="l00288"></a>00288 
<a name="l00302"></a><a class="code" href="group__buf.html#gaab387f86a4663244fa4f61f981609b74">00302</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#gaab387f86a4663244fa4f61f981609b74" title="Removes bytes from the tail of the buffer.">u_buf_shrink</a>(<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf, <span class="keywordtype">size_t</span> newlen)
<a name="l00303"></a>00303 {
<a name="l00304"></a>00304     dbg_err_if (ubuf == NULL);
<a name="l00305"></a>00305     dbg_err_if (newlen &gt; ubuf-&gt;len);
<a name="l00306"></a>00306 
<a name="l00307"></a>00307     ubuf-&gt;len = newlen;
<a name="l00308"></a>00308 
<a name="l00309"></a>00309     <span class="keywordflow">return</span> 0;
<a name="l00310"></a>00310 err:
<a name="l00311"></a>00311     <span class="keywordflow">return</span> ~0;
<a name="l00312"></a>00312 }
<a name="l00313"></a>00313 
<a name="l00324"></a><a class="code" href="group__buf.html#ga9cbad104b02a300588a4fedb77d8746d">00324</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga9cbad104b02a300588a4fedb77d8746d" title="Free a buffer.">u_buf_free</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326     dbg_return_if (ubuf == NULL, ~0);
<a name="l00327"></a>00327 
<a name="l00328"></a>00328     U_FREE(ubuf-&gt;data);
<a name="l00329"></a>00329     <a class="code" href="group__alloc.html#ga8a480341289bf5fc1a72e7974c4a739d" title="Wrapper for free-like function, sanity checks the supplied pointer.">u_free</a>(ubuf);
<a name="l00330"></a>00330 
<a name="l00331"></a>00331     <span class="keywordflow">return</span> 0;
<a name="l00332"></a>00332 }
<a name="l00333"></a>00333 
<a name="l00349"></a><a class="code" href="group__buf.html#gac5382645184c7054885617e65321b852">00349</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#gac5382645184c7054885617e65321b852" title="Append a string to the given buffer.">u_buf_printf</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
<a name="l00350"></a>00350 {
<a name="l00351"></a>00351     va_list ap;
<a name="l00352"></a>00352     <span class="keywordtype">size_t</span> sz, avail;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     dbg_return_if (ubuf == NULL, ~0);
<a name="l00355"></a>00355     dbg_return_if (fmt == NULL, ~0);
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 again:
<a name="l00358"></a>00358     va_start(ap, fmt); 
<a name="l00359"></a>00359 
<a name="l00360"></a>00360     avail = ubuf-&gt;size - ubuf-&gt;len; <span class="comment">/* avail may be zero */</span>
<a name="l00361"></a>00361 
<a name="l00362"></a>00362     <span class="comment">/* write to the internal buffer of ubuf */</span>
<a name="l00363"></a>00363     dbg_err_if ((sz = vsnprintf(ubuf-&gt;data + ubuf-&gt;len, avail, fmt, ap)) &lt;= 0);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365     <span class="keywordflow">if</span> (sz &gt;= avail)
<a name="l00366"></a>00366     {
<a name="l00367"></a>00367         <span class="comment">/* enlarge the buffer (make it at least 128 bytes bigger) */</span>
<a name="l00368"></a>00368         dbg_err_if (<a class="code" href="group__buf.html#ga280dd0228033fb8d8ef60051ac211367" title="Enlarge the memory allocated to a given buffer.">u_buf_reserve</a>(ubuf, ubuf-&gt;len + U_MIN(128, sz + 1)));
<a name="l00369"></a>00369 
<a name="l00370"></a>00370         <span class="comment">/* zero-term the buffer (vsnprintf has removed the last \0!) */</span>
<a name="l00371"></a>00371         ubuf-&gt;data[ubuf-&gt;len] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373         va_end(ap);
<a name="l00374"></a>00374 
<a name="l00375"></a>00375         <span class="comment">/* try again with a bigger buffer */</span>
<a name="l00376"></a>00376         <span class="keywordflow">goto</span> again;
<a name="l00377"></a>00377     }
<a name="l00378"></a>00378 
<a name="l00379"></a>00379     <span class="comment">/* update data length (don&#39;t include the &#39;\0&#39; in the size count) */</span>
<a name="l00380"></a>00380     ubuf-&gt;len += sz; 
<a name="l00381"></a>00381 
<a name="l00382"></a>00382     va_end(ap);
<a name="l00383"></a>00383 
<a name="l00384"></a>00384     <span class="keywordflow">return</span> 0;
<a name="l00385"></a>00385 err:
<a name="l00386"></a>00386     va_end(ap);
<a name="l00387"></a>00387     <span class="keywordflow">return</span> ~0;
<a name="l00388"></a>00388 }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 
<a name="l00402"></a><a class="code" href="group__buf.html#ga3fe4ec3d0e04629f4177efb5aa43233c">00402</a> <span class="keywordtype">int</span> <a class="code" href="group__buf.html#ga3fe4ec3d0e04629f4177efb5aa43233c" title="Create a new buffer.">u_buf_create</a> (<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> **pubuf)
<a name="l00403"></a>00403 {
<a name="l00404"></a>00404     <a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a> *ubuf = NULL;
<a name="l00405"></a>00405 
<a name="l00406"></a>00406     dbg_return_if (pubuf == NULL, ~0);
<a name="l00407"></a>00407 
<a name="l00408"></a>00408     dbg_err_sif ((ubuf = <a class="code" href="group__alloc.html#gad508e24d765a79bd7e15feade062407c" title="Alloc a contiguous region of sz bytes and zero-fill it.">u_zalloc</a>(<span class="keyword">sizeof</span>(<a class="code" href="group__buf.html#ga3caf623cdac2dda0f17f3d4086c79a11" title="The basic buffer type. Internally it hides the data buffer which can be accessed...">u_buf_t</a>))) == NULL);
<a name="l00409"></a>00409 
<a name="l00410"></a>00410     ubuf-&gt;len = 0;
<a name="l00411"></a>00411     ubuf-&gt;size = 0;
<a name="l00412"></a>00412     ubuf-&gt;data = NULL;
<a name="l00413"></a>00413 
<a name="l00414"></a>00414     *pubuf = ubuf;
<a name="l00415"></a>00415 
<a name="l00416"></a>00416     <span class="keywordflow">return</span> 0;
<a name="l00417"></a>00417 err:
<a name="l00418"></a>00418     <span class="keywordflow">return</span> ~0;
<a name="l00419"></a>00419 }
<a name="l00420"></a>00420 
</pre></div></div>
<hr>
<div>
  <div style="text-align:left">
    <a href="http://www.koanlogic.com/products.html">&larr;Products</a>
  </div>
  <div style="text-align:center;">
    &copy; 2005-2012 - <a href="http://www.koanlogic.com">KoanLogic S.r.l.</a> - All rights reserved
  </div>
</div>

</body>
</html>
